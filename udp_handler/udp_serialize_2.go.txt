package udp_handler

import (
	"bytes"
	"encoding/binary"
	"errors"
	"fmt"
)

// Existing type definitions remain the same
type PacketType uint8

const (
	TaskPacket     PacketType = 0
	RegisterPacket PacketType = 1
	ReportPacket   PacketType = 2
)

type Flags struct {
	SYN bool
	ACK bool
	RET bool
}

type AgentRegistration struct {
	AgentID  string
	IPv4     string
	ClientID string
}

type TaskRecord struct {
	TaskID         string
	Name           string
	Value          string
	Threshold      float64
	Duration       uint32
	PacketCount    uint32
	Frequency      uint32
	ReportFreq     uint32
	CriticalValues []string
	ClientID       string
}

type ReportRecord struct {
	TaskID   string
	Name     string
	Value    string
	ClientID string
}

type Packet struct {
	Type           PacketType
	SequenceNumber uint32
	AckNumber      uint32
	Flags          Flags
	Data           interface{}
}

// Updated Serialize method
func (p *Packet) Serialize() ([]byte, error) {
	buf := new(bytes.Buffer)

	// Header serialization remains the same
	packetType := uint8(p.Type) << 6
	if err := binary.Write(buf, binary.BigEndian, packetType); err != nil {
		return nil, err
	}
	if err := binary.Write(buf, binary.BigEndian, p.SequenceNumber); err != nil {
		return nil, err
	}
	if err := binary.Write(buf, binary.BigEndian, p.AckNumber); err != nil {
		return nil, err
	}

	var flags uint8
	if p.Flags.SYN {
		flags |= 1 << 2
	}
	if p.Flags.ACK {
		flags |= 1 << 1
	}
	if p.Flags.RET {
		flags |= 1
	}
	if err := binary.Write(buf, binary.BigEndian, flags); err != nil {
		return nil, err
	}

	switch p.Type {
	case RegisterPacket:
		reg, ok := p.Data.(AgentRegistration)
		if !ok {
			return nil, errors.New("invalid data type for RegisterPacket")
		}
		if err := writeString(buf, reg.AgentID); err != nil {
			return nil, err
		}
		if err := writeString(buf, reg.IPv4); err != nil {
			return nil, err
		}
		if err := writeString(buf, reg.ClientID); err != nil {
			return nil, err
		}

	case TaskPacket:
		tasks, ok := p.Data.([]TaskRecord)
		if !ok {
			return nil, errors.New("invalid data type for TaskPacket")
		}
		if err := binary.Write(buf, binary.BigEndian, uint32(len(tasks))); err != nil {
			return nil, err
		}
		for _, task := range tasks {
			for _, s := range []string{task.TaskID, task.Name, task.Value, task.ClientID} {
				if err := writeString(buf, s); err != nil {
					return nil, err
				}
			}
			for _, v := range []interface{}{task.Threshold, task.Duration, task.PacketCount, task.Frequency, task.ReportFreq} {
				if err := binary.Write(buf, binary.BigEndian, v); err != nil {
					return nil, err
				}
			}
			if err := binary.Write(buf, binary.BigEndian, uint32(len(task.CriticalValues))); err != nil {
				return nil, err
			}
			for _, cv := range task.CriticalValues {
				if err := writeString(buf, cv); err != nil {
					return nil, err
				}
			}
		}

	case ReportPacket:
		reports, ok := p.Data.([]ReportRecord)
		if !ok {
			return nil, errors.New("invalid data type for ReportPacket")
		}
		if err := binary.Write(buf, binary.BigEndian, uint32(len(reports))); err != nil {
			return nil, err
		}
		for _, report := range reports {
			for _, s := range []string{report.TaskID, report.Name, report.Value, report.ClientID} {
				if err := writeString(buf, s); err != nil {
					return nil, err
				}
			}
		}
	}

	return buf.Bytes(), nil
}

// Updated Deserialize method
func Deserialize(data []byte) (*Packet, error) {
	buf := bytes.NewReader(data)
	packet := &Packet{}

	// Header deserialization remains the same
	var packetTypeByte uint8
	if err := binary.Read(buf, binary.BigEndian, &packetTypeByte); err != nil {
		return nil, err
	}
	packet.Type = PacketType(packetTypeByte >> 6)

	if err := binary.Read(buf, binary.BigEndian, &packet.SequenceNumber); err != nil {
		return nil, err
	}
	if err := binary.Read(buf, binary.BigEndian, &packet.AckNumber); err != nil {
		return nil, err
	}

	var flags uint8
	if err := binary.Read(buf, binary.BigEndian, &flags); err != nil {
		return nil, err
	}
	packet.Flags = Flags{
		SYN: flags&(1<<2) != 0,
		ACK: flags&(1<<1) != 0,
		RET: flags&1 != 0,
	}

	switch packet.Type {
	case RegisterPacket:
		reg := AgentRegistration{}
		var err error
		if reg.AgentID, err = readString(buf); err != nil {
			return nil, err
		}
		if reg.IPv4, err = readString(buf); err != nil {
			return nil, err
		}
		if reg.ClientID, err = readString(buf); err != nil {
			return nil, err
		}
		packet.Data = reg

	case TaskPacket:
		var numTasks uint32
		if err := binary.Read(buf, binary.BigEndian, &numTasks); err != nil {
			return nil, err
		}
		tasks := make([]TaskRecord, numTasks)
		for i := range tasks {
			task := &tasks[i]
			var err error
			if task.TaskID, err = readString(buf); err != nil {
				return nil, err
			}
			if task.Name, err = readString(buf); err != nil {
				return nil, err
			}
			if task.Value, err = readString(buf); err != nil {
				return nil, err
			}
			if task.ClientID, err = readString(buf); err != nil {
				return nil, err
			}
			for _, v := range []interface{}{&task.Threshold, &task.Duration, &task.PacketCount, &task.Frequency, &task.ReportFreq} {
				if err := binary.Read(buf, binary.BigEndian, v); err != nil {
					return nil, err
				}
			}
			var numCriticalValues uint32
			if err := binary.Read(buf, binary.BigEndian, &numCriticalValues); err != nil {
				return nil, err
			}
			task.CriticalValues = make([]string, numCriticalValues)
			for j := range task.CriticalValues {
				if task.CriticalValues[j], err = readString(buf); err != nil {
					return nil, err
				}
			}
		}
		packet.Data = tasks

	case ReportPacket:
		var numReports uint32
		if err := binary.Read(buf, binary.BigEndian, &numReports); err != nil {
			return nil, err
		}
		reports := make([]ReportRecord, numReports)
		for i := range reports {
			report := &reports[i]
			var err error
			if report.TaskID, err = readString(buf); err != nil {
				return nil, err
			}
			if report.Name, err = readString(buf); err != nil {
				return nil, err
			}
			if report.Value, err = readString(buf); err != nil {
				return nil, err
			}
			if report.ClientID, err = readString(buf); err != nil {
				return nil, err
			}
		}
		packet.Data = reports
	}

	return packet, nil
}

// Helper functions and String method remain the same
func writeString(buf *bytes.Buffer, s string) error {
	if err := binary.Write(buf, binary.BigEndian, uint32(len(s))); err != nil {
		return err
	}
	_, err := buf.WriteString(s)
	return err
}

func readString(buf *bytes.Reader) (string, error) {
	var length uint32
	if err := binary.Read(buf, binary.BigEndian, &length); err != nil {
		return "", err
	}
	strBytes := make([]byte, length)
	if _, err := buf.Read(strBytes); err != nil {
		return "", err
	}
	return string(strBytes), nil
}

func (pt PacketType) String() string {
	switch pt {
	case TaskPacket:
		return "TaskPacket"
	case RegisterPacket:
		return "RegisterPacket"
	case ReportPacket:
		return "ReportPacket"
	default:
		return fmt.Sprintf("Unknown(%d)", pt)
	}
}

// Print prints the packet information to console
func (p *Packet) Print() {
	fmt.Printf("=== Packet Information ===\n")
	fmt.Printf("Type: %s (value: %d)\n", p.Type, p.Type)
	fmt.Printf("Sequence Number: %d\n", p.SequenceNumber)
	fmt.Printf("Ack Number: %d\n", p.AckNumber)
	fmt.Printf("Flags: SYN=%v ACK=%v RET=%v\n", p.Flags.SYN, p.Flags.ACK, p.Flags.RET)
	
	fmt.Printf("Data: ")
	switch data := p.Data.(type) {
	case AgentRegistration:
		fmt.Printf("Registration Data\n")
		fmt.Printf("  Agent ID: %s\n", data.AgentID)
		fmt.Printf("  IPv4: %s\n", data.IPv4)
		fmt.Printf("  Client ID: %s\n", data.ClientID)
	
	case []TaskRecord:
		fmt.Printf("Task Records (%d items)\n", len(data))
		for i, task := range data {
			fmt.Printf("  Task #%d:\n", i+1)
			fmt.Printf("    Task ID: %s\n", task.TaskID)
			fmt.Printf("    Name: %s\n", task.Name)
			fmt.Printf("    Value: %s\n", task.Value)
			fmt.Printf("    Threshold: %f\n", task.Threshold)
			fmt.Printf("    Duration: %d\n", task.Duration)
			fmt.Printf("    Packet Count: %d\n", task.PacketCount)
			fmt.Printf("    Frequency: %d\n", task.Frequency)
			fmt.Printf("    Report Frequency: %d\n", task.ReportFreq)
			fmt.Printf("    Critical Values: %v\n", task.CriticalValues)
			fmt.Printf("    Client ID: %s\n", task.ClientID)
		}
	
	case []ReportRecord:
		fmt.Printf("Report Records (%d items)\n", len(data))
		for i, report := range data {
			fmt.Printf("  Report #%d:\n", i+1)
			fmt.Printf("    Task ID: %s\n", report.TaskID)
			fmt.Printf("    Name: %s\n", report.Name)
			fmt.Printf("    Value: %s\n", report.Value)
			fmt.Printf("    Client ID: %s\n", report.ClientID)
		}
	
	default:
		fmt.Printf("Unknown data type\n")
	}
	fmt.Println("=====================")
}